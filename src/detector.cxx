#include "detector.h"
#include <algorithm>
#include <cmath>
#include <boost/filesystem.hpp>
#include "date/date.h"
#include "utility.h"

// Detector
// Copyright (C) 2021, Lawrence Livermore National Security, LLC.
//  All rights reserved. LLNL-CODE-837067
//
// The Department of Homeland Security sponsored the production of this
//  material under DOE Contract Number DE-AC52-07N427344 for the management
//  and operation of Lawrence Livermore National Laboratory. Contract no.
//  DE-AC52-07NA27344 is between the U.S. Department of Energy (DOE) and
//  Lawrence Livermore National Security, LLC (LLNS) for the operation of LLNL.
//  See license for disclaimers, notice of U.S. Government Rights and license
//  terms and conditions.

namespace tmon
{

Detector::Detector(string_view name, const ProgState& prog_state,
    Alerter& alerter)
        : Task{name, prog_state}, cond_{}, msg_mutex_{}, registry_mutex_{},
            min_to_process_{1}, msg_cont_{}, processing_msg_cont_{},
            alg_cont_{}, alerter_{alerter},
            alert_listener_{alerter_.register_listener()},
            prev_alert_msg_level_{}, msg_queue_{},
            mode_{Mode::Detection}
{
    msg_cont_.reserve(min_to_process_);
    processing_msg_cont_.reserve(msg_cont_.capacity());
    int window_len = get_opt_as<int>("det.window_len");
    double kf_thresh_sigma = get_opt_as<double>("det.thresh_sigma");
    double kf_lower_thresh_sigma = get_opt_as<double>("det.lower_thresh_sigma");
    double kf_meas_noise = get_opt_as<double>("det.meas_noise");
    alg_cont_.emplace_back(std::make_unique<KFDetectorAlg>(prog_state,
        window_len, kf_thresh_sigma, kf_lower_thresh_sigma, kf_meas_noise));
    std::string timemsg_file = get_opt_as<std::string>("tmp.timemsg_file");
    if (timemsg_file != "disable")
    {
        if (boost::filesystem::exists(timemsg_file))
        {
            std::string logfile_bak = timemsg_file + date::format(
                ".%F-%H%M%S.bak", date::floor<std::chrono::seconds>(
                    std::chrono::system_clock::now()));
            boost::filesystem::copy_file(timemsg_file, logfile_bak);
        }
        alg_cont_.emplace_back(std::make_unique<FileWriterPseudoAlg>(prog_state,
            timemsg_file));
    }

    bool cal_enabled = get_opt_as<bool>("cal.enabled");
    if (cal_enabled)
    {
        mode_ = Mode::Calibration;
        cal_start_ = std::chrono::steady_clock::now();
        CalibrationMsg cal_start_msg{CalibrationMsg::EventType::start};
        handle_cal_msg(cal_start_msg);
    }
}

// Call under lock on msg_mutex_
bool Detector::ready_to_process() const noexcept
{
    return (msg_cont_.size() >= min_to_process_);
}

void Detector::run()
{
    BOOST_LOG_FUNCTION();
    TM_LOG(debug) << "Running detector";

    while (!should_quit())
    {
        {
            unique_lock<mutex> guard{msg_mutex_};
            cond_.wait(guard,
                [this]{ return this->should_quit() ||
                    this->ready_to_process(); });
        }
        // Could be here due to interruption; spurious wakeup should be handled
        //  by the call to wait
        if (should_quit())
            break;
        assert(ready_to_process());
        TM_LOG(debug) << "Detector ready to process";

        // Swap in a new empty container under mutex lock and process messages
        //  in the swapped out container (minimizing mutex region without
        //  incurring a memory allocation, since the processing container is
        //  retained within the Detector state and swap is O(1))
        assert(processing_msg_cont_.empty());
        {
            lock_guard<mutex> guard{msg_mutex_};
            msg_cont_.swap(processing_msg_cont_);
        }
        process_time_msgs(processing_msg_cont_);
        processing_msg_cont_.clear();

        // Check if calibration period has elapsed; if so, switch to detection
        //  mode
        if (mode_ == Mode::Calibration)
            check_if_cal_done();

        // Process alert messages received from the Alerter module
        //  (this will include enqueuing messages originally raised from this
        //  module as well as any clear-alert messages generated by the Alerter
        //  itself into the Detector message queue)
        process_alert_msgs();
    }
}

void Detector::check_if_cal_done()
{
    auto elapsed_cal_dur = std::chrono::steady_clock::now() - cal_start_;
    std::chrono::seconds cal_dur{get_opt_as<int>("cal.duration")};
    if (elapsed_cal_dur > cal_dur)
    {
        TM_LOG(info) << "Calibration period completed; applying calibration "
            "and switching to detection mode";
        // Detection algorithms should maintain a flag indicating their
        //  calibration state and apply the calibration as needed when first
        //  processing in detection mode
        mode_ = Mode::Detection;
    }
}

void Detector::stop_hook()
{
    TM_LOG(debug) << "Detector stopping; interrupting blocking calls";
    cond_.notify_all();
    alert_listener_.cancel();
}

std::string Detector::describe_clock(tmon::ClockId clk_id) const
{
    using std::to_string;
    std::string ret{to_string(clk_id)};
    unique_lock<mutex> guard{registry_mutex_};
    auto match = clock_registry_.find(clk_id);
    if (match == clock_registry_.end())
    {
        guard.unlock();
        ret += ":<UNKNOWN>";
        return ret;
    }
    return ret + ":" + match->second.describe();
}

GaussMarkovModel Detector::get_gauss_markov_clock_model(
    tmon::ClockId clk_id) const
{
    unique_lock<mutex> guard{registry_mutex_};
    auto match = clock_registry_.find(clk_id);
    assert(match != clock_registry_.end());
    return match->second.gm_model;
}

TimeMsgHeader Detector::get_header() const
{
    unique_lock<mutex> guard{registry_mutex_};
    TimeMsgHeader ret{"1.0", clock_registry_};
    return ret;
}

bool Detector::is_processing() const
{
    // The processing message container is cleared after processing completes
    //  at each step; if it has any items (or the detector is ready to process,
    //  in which case it will immediately begin processing), indicate that the
    //  detector is in processing mode
    unique_lock<mutex> guard{msg_mutex_};
    return ready_to_process() || !processing_msg_cont_.empty();
}

bool Detector::is_clock_registered(const tmon::ClockDesc& desc) const
{
    lock_guard<mutex> guard{registry_mutex_};
    return is_clock_registered(desc, guard);
}

// Call under lock on registry_mutex_ (passed as second parameter)
bool Detector::is_clock_registered(const tmon::ClockDesc& desc,
    const lock_guard<mutex>&) const
{
    using std::cbegin;
    using std::cend;
    return std::any_of(cbegin(clock_registry_), cend(clock_registry_),
        [&desc](const auto& x){ return x.second == desc; });
}

tmon::ClockId Detector::register_clock(const tmon::ClockDesc& desc)
    /* throws runtime_error */
{
    BOOST_LOG_FUNCTION();
    ClockId new_id{};

    {
        lock_guard<mutex> guard{registry_mutex_};
        if (is_clock_registered(desc, guard))
        {
            throw std::runtime_error("Clock '" + desc.describe() +
                "' double-registered");
        }
        if (!clock_registry_.empty())
        {
            ClockId last_id = clock_registry_.crbegin()->first;
            new_id = ++last_id;
        }
        auto insert_ret = clock_registry_.insert(std::make_pair(new_id, desc));
        // Insert must succeed or logic guaranteeing unique ID above is wrong
        assert(insert_ret.second == true);
        auto insert_ret2 = clock_done_flags_.insert(
            std::make_pair(new_id, false));
        assert(insert_ret2.second == true);
    } // release lock

    // Register clock with each detector algorithm (unless the diffusion
    //  coefficients have a NaN, which indicates a pseudo-clock)
    bool q_has_nan = desc.gm_model.q.unaryExpr([](const auto& x){
        return std::isnan(x); }).any();
    if (!q_has_nan)
    {
        for (const auto& alg : alg_cont_)
        {
            assert(alg);
            alg->register_clock(new_id, desc);
        }
    }

    TM_LOG(debug) << "Detector registered clock #" << new_id << ":"
        << desc.describe();
    return new_id;
}

// Removes a clock ID from the clock registry
//  Returns true if the clock was previously registered, false otherwise
bool Detector::unregister_clock(tmon::ClockId clk_id)
{
    BOOST_LOG_FUNCTION();
    TM_LOG(debug) << "Detector unregistering clock " << describe_clock(clk_id);

    bool ret;
    {
        lock_guard<mutex> guard{registry_mutex_};
        ret = clock_registry_.erase(clk_id) != 0;
        clock_done_flags_.erase(clk_id);
    }

    if (!ret)
        return false; // nothing to unregister; clock ID not found

    if (!should_quit())
    {
        // Lost a clock in the middle of operation (since clocks unregister
        //  themselves during destruction); check if alert is to be raised
        //
        auto lost_clock_lvl = get_opt_as<Alert::Level>(
            "alert.level.lost_clock");
        using std::to_string;
        tmon::Alert alert{lost_clock_lvl, tmon::Alert::ReasonCode::lost_clock,
            "Early disconnection of clock " + to_string(clk_id)};
        raise_alert(alert);
    }

    // Purge all time messages referencing the now-unregistered clock
    {
        lock_guard<mutex> guard{msg_mutex_};
        using std::begin;
        using std::end;
        auto any_clk_id_match_fn = [clk_id](const auto& x){
            return (x.clock_id == clk_id) ||
                std::any_of(begin(x.comparisons), end(x.comparisons),
                    [clk_id](const auto& c){
                        return c.other_clock_id == clk_id; }); };
        msg_cont_.erase(std::remove_if(begin(msg_cont_), end(msg_cont_),
            any_clk_id_match_fn), end(msg_cont_));
    }

    // Unregister clock with detection algorithms
    for (const auto& alg : alg_cont_)
    {
        assert(alg);
        alg->unregister_clock(clk_id);
    }

    return ret;
}

bool Detector::all_clocks_done() const
{
    using std::cbegin;
    using std::cend;
    unique_lock<mutex> guard{registry_mutex_};
    return std::all_of(cbegin(clock_done_flags_), cend(clock_done_flags_),
        [](const auto& x){ return x.second; });
}

Detector::Mode Detector::get_mode() const noexcept
{
    return mode_;
}

void Detector::handle_clock_done(ClockId clk_id)
{
    unique_lock<mutex> guard{registry_mutex_};
    auto match = clock_done_flags_.find(clk_id);
    assert(match != clock_done_flags_.end());
    match->second = true;
}

void Detector::handle_time_msg(TimeMsg msg)
{
    TM_LOG(trace) << "Detector received time msg for clk "
        << describe_clock(msg.clock_id) << ": " 
        << to_string(msg.msg_creation)
        << " at creation; originated at " 
        << to_string(msg.orig_timestamp)
        << "; " << msg.comparisons.size() << " comparison(s) follow";

    for (const auto& x : msg.comparisons)
    {
        TM_LOG(trace) << "Clk "
            << describe_clock(msg.clock_id) << " vs Clk "
            << describe_clock(x.other_clock_id) << ": "
            << date::format("%T", x.time_versus_other);
    }

    // Add message to container and notify detector thread to check if it's
    //  ready for processing a batch
    {
        lock_guard<mutex> guard{msg_mutex_};
        msg_cont_.emplace_back(std::move(msg));
    }
    cond_.notify_one();
}

void Detector::process_time_msgs(const TimeMsgCont& msgs)
{
    TM_LOG(debug) << "Detector processing " << msgs.size() << " time msg(s)";

    // Call all detection algorithms with this batch of data
    for (const auto& alg : alg_cont_)
    {
        assert(alg);
        switch (get_mode())
        {
            case Mode::Calibration:
                alg->process_cal(msgs, *this);
                break;
            case Mode::Detection:
                alg->process_det(msgs, *this);
                break;
        }
    }
    TM_LOG(debug) << "Detector processed " << msgs.size() << " time msg(s)";
}

void Detector::raise_alert(tmon::Alert alert)
{
    TM_LOG(error) << describe(alert);
    alerter_.raise_alert(alert);
}

void Detector::process_alert_msgs()
{
    if (alert_listener_.empty())
        return;
    // TODO: Revisit whether intermittent alert messages should be enqueued
    //  even if the level is unchanged
    while (optional<Alert> alert = alert_listener_.pop_front())
    {
        if (!prev_alert_msg_level_ || (alert->level != *prev_alert_msg_level_))
        {
            prev_alert_msg_level_ = alert->level;
            msg_queue_.push_back(std::move(*alert));
        }
    }
}

void Detector::handle_cal_msg(CalibrationMsg msg)
{
    msg_queue_.push_back(std::move(msg));
}

void Detector::handle_det_metric_msg(DetMetricMsg msg)
{
    msg_queue_.push_back(std::move(msg));
}

auto Detector::register_msg_queue_listener() -> MsgQueue::Listener
{
    return msg_queue_.get_new_listener();
}

} // end namespace tmon

// Copyright (C) 2021, Lawrence Livermore National Security, LLC.
//  All rights reserved. LLNL-CODE-837067
//
// The Department of Homeland Security sponsored the production of this
//  material under DOE Contract Number DE-AC52-07N427344 for the management
//  and operation of Lawrence Livermore National Laboratory. Contract no.
//  DE-AC52-07NA27344 is between the U.S. Department of Energy (DOE) and
//  Lawrence Livermore National Security, LLC (LLNS) for the operation of LLNL.
//  See license for disclaimers, notice of U.S. Government Rights and license
//  terms and conditions.

